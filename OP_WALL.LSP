(defun op_ins (/ wd)
	(if in_door nil (load "door.lsp"))
	(if in_win nil (load "win.lsp"))
	(if op_wd nil (setq op_wd "Door"))
	(initget "Window Door None")
	(princ "\nInsert:[Window/Door/None]. <")
	(princ op_wd)
	(setq wd (getkword ">:"))
	(if wd nil (setq wd op_wd))
	(setq op_wd wd)
	(cond
		((= wd "Door") (in_door op_ss))
		((= wd "Window") (in_win op_ss))
		(t)
	)
)

(defun op_wall (/ pt1 pt2 ang1 ang01 ang02 pt0 pt3 pt4 ss ent2 dtct_wid insu ufac pt5 pt6 int ang2 wid pt7 pt8 pt9 pt10 pt dis0 grid_wid)
	(setq insu (getvar "insunits"))
	(cond
		((= insu 0)
			(setq ufac 1.0)
		)
		((= insu 4);毫米
			(setq ufac 1.0)
		)
		((= insu 5);厘米
			(setq ufac 0.1)
		)
		((= insu 6);米
			(setq ufac 0.001)
		)
		(t 
			(setq ufac 1.0)
		)
	);cond
	(setq 
		pt1 (cdr (assoc 10 ent1))
		pt2 (cdr (assoc 11 ent1))
		dtct_wid (* 350.0 ufac)
		grid_wid 50
		ang1 (angle pt1 pt2)
		ang01 (+ ang1 (/ pi 2.0))
		ang02 (- ang1 (/ pi 2.0))
		pt0 (cadr en)
		pt3 (polar pt0 ang01 dtct_wid)
		pt4 (polar pt0 ang02 dtct_wid)
		ss (ssget "f" (list pt3 pt4))
		ss (ssget "p" (list (cons 8 FLLT_WALL) '(0 . "line")))
		ss (ssdel (car en) ss)
	)
	(if (= (sslength ss) 1)
		(progn
			; <<< 插入点取整
			(setq 
				pt0 (inters pt3 pt4 pt1 pt2)
				dis0 (fix (/ (distance pt1 pt0) ufac))
				dis0 (* (if (> dis0 grid_wid) (- dis0 (rem dis0 grid_wid)) grid_wid) ufac)
				pt0 (polar pt1 ang1 dis0)
				pt3 (polar pt0 ang01 dtct_wid)
				pt4 (polar pt0 ang02 dtct_wid)
			)
			; 插入点取整 >>>
			(princ "\nWidth to open <")
			(if op_wid nil (setq op_wid (* 900.0 ufac)))
			(princ op_wid)
			(princ ">: ")
			(setq wid (getdist))
			(if wid nil (setq wid op_wid))
			(setq op_wid wid wid (/ wid 2.0))
			(setq 
				ent2 (entget (ssname ss 0))
				pt5 (cdr (assoc 10 ent2))
				pt6 (cdr (assoc 11 ent2))
				ang2 (angle pt5 pt6)
				int (inters pt3 pt4 pt5 pt6)
				pt0 (inters pt3 pt4 pt1 pt2)
				pt7 (polar pt0 ang1 wid)
				pt8 (polar int ang2 wid)
				pt9 (polar pt0 ang1 (* -1 wid))
				pt10 (polar int ang2 (* -1 wid))
			)
			(entmod (subst (cons 11 pt9) (assoc 11 ent1) ent1))
			(entmod (subst (cons 11 pt10) (assoc 11 ent2) ent2))
			(entmake (list (cons 0 "line") (cons 8 FLLT_WALL) (cons 10 pt7) (cons 11 pt2)))
			(entmake (list (cons 0 "line") (cons 8 FLLT_WALL) (cons 10 pt8) (cons 11 pt6)))
			(if (inters pt7 pt8 pt9 pt10)
				(setq pt pt8 pt8 pt10 pt10 pt pt nil)
			)
			(setq op_ss (ssadd))
			(entmake (list (cons 0 "line") (cons 8 FLLT_WALL) (cons 10 pt7) (cons 11 pt8)))
			(setq op_ss (ssadd (entlast) op_ss))
			(entmake (list (cons 0 "line") (cons 8 FLLT_WALL) (cons 10 pt9) (cons 11 pt10)))
			(setq op_ss (ssadd (entlast) op_ss))
		)
	)
)

(defun c:dw (/ ucsf en ln wl ent1 op_ss yn)
	(setq olderr *error*)
	(defun *error* (s)
		(setvar "cmdecho" 0)
		(fl_undo_end)
		(setq *error* olderr)
		(princ)
	)
	(princ "\nFishLISP, Oct. 8 1996")
	(setvar "cmdecho" 0)
	(fl_undo_begin)
	(setq ucsf (getvar "ucsfollow"))
	(setvar "ucsfollow" 0)
	(setvar "expert" 4)
	(cmd "ucs" "s""$temp$")
	(cmd "ucs" "w")
	(if
		(and
			(setq en (entsel "\nPick a wall-line:"))
			(= (setq ln (cdr (assoc 0 (setq ent1 (entget (car en)))))) "LINE")
			(= (setq wl (strcase (cdr (assoc 8 ent1)))) FLLT_WALL)
		)
		(progn 
			(op_wall) 
			(if op_ss (op_ins))
		)
		(cond
			((not en) (alert "You picked nothing"))
			((/= ln "LINE") (alert "The selection is not Line"))
			((/= wl FLLT_WALL) (alert "The Line is not on layer Wall"))
		)
	)

	(cmd "ucs" "r" "$temp$")
	(cmd "ucs" "d" "$temp$")
	(setvar "ucsfollow" ucsf)
	(fl_undo_end)
	(setvar "expert" 0)
	(setvar "cmdecho" 1)
	(setq *error* olderr)

	(princ)
)

(princ "loaded. Start as C:DW")
(princ)
