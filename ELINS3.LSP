; 2025-11-18			大幅度重写
; 2014/01/24	v3.0	增加D挝槊r的理
; 1999/08/28	v2.6	更灵活的 block 选择.
; 1998/01/13	Bug: Not work in UCS.
; 1995/12/13

(load "function")

(setvar "cmdecho" 0)
(if (tblsearch "layer" FLLT_DIM0)
	nil
	(cmd "layer" "n" FLLT_DIM0 "c" "g" FLLT_DIM0 "")
)
(setvar "cmdecho" 1)

(defun c:elin (/ olderr os cl aq EL_SCALE UNIT_SCALE)
	(setq olderr *error*)
	(defun *error* (s)
		(setvar "osmode" (if os os 175))
		(setvar "clayer" (if cl  cl "0"))
		(setvar "attreq" (if aq aq 1))
		(setvar "cmdecho" 0)
		;(undoend)
		(setvar "cmdecho" 1)
		(setq *error* olderr olderr nil os nil cl nil aq nil)
		(princ)
	)
	(setq
		os (getvar "osmode")
		cl (getvar "clayer")
		aq (getvar "attreq")
	)
	(setq UNIT_SCALE (if (= (getvar "insunits") 6) 1.0 0.001))
	(setvar "cmdecho" 0)
	(setvar "dimzin" 0)
	(setvar "attreq" 1)
	(cmd "_undo" "g")
	(setvar "clayer" FLLT_DIM0)
	(if EL_BASE_Y nil (el_ini))
	(setq EL_SUFFIX (if EL_SUFFIX EL_SUFFIX "UR"))
	(setq EL_SCALE (getvar "dimscale"))
	(el_main)
	(setvar "osmode" os)
	(setvar "clayer" cl)
	(setvar "cmdecho" 0)
	(setvar "attreq" aq)
	(cmd "_undo" "end")
	(setvar "cmdecho" 1)
	(setq *error* olderr)
	(princ)
)

(defun el_main ()
	(initget "Copy Move Array UL UR DL DR Plan Base")
	(setq pt1 (getpoint 
		(strcat "\nPlan mode/Base point/Copy/Move/Array/block:[" 
				(strcase EL_SUFFIX) 
				"]/<insert point>: "
		)
	))
	(cond
		((listp pt1) (el_insert))
		((= pt1 "Copy")	(el_copy))
		((= pt1 "Move")	(el_move))
		((= pt1 "Array") (el_array))
		((member pt1 (list "UL" "UR" "DL" "DR"))
			(setq EL_SUFFIX pt1)
			(el_main)
		)
		((= pt1 "Plan")
			(defun c:elin ()
				(el_plan_mode)
				(princ)
			)
			(c:elin)
		)
		((= pt1 "Value") (el_val))
		((= pt1 "Base")
			(el_base)
			(el_main)
		)
		(t)
	)
)

; ok
(defun el_insert (/ el_y1 cl loop)
	(while pt1
		(setq el_y1 (rtos (princ (* (- (cadr pt1) EL_BASE_Y) UNIT_SCALE)) 2 3))
		(insert_el el_y1)
		(setq loop t)
		(while loop
			(initget "UL UR DL DR")
			(setq pt1 (getpoint (strcat "\nblock:[" EL_SUFFIX "]/" "<insert point>: ")))
			(if (listp pt1)
				(setq loop nil)
				(setq EL_SUFFIX pt1)
			)
		)
	)
)

; ok
(defun insert_el (attr / tmpval)
	(setq tmpval (getstring (strcat "\nElevation: <" attr ">: ")))
	(if (= tmpval "") nil (setq attr tmpval))
	(if (= attr "0.000") (setq attr "%%P0.000"))
	;(cmd "_undo" "end")
	;(cmd "_undo" "g")
	(setvar "osmode" 0)
	(cmd "_insert" (strcat "EL" EL_SUFFIX) pt1 EL_SCALE EL_SCALE 0 attr)
	(setvar "osmode" os)
)

; ok
(defun el_copy (/ en ent a0 y0 pt0 pt1)
	(setq en (car (entsel "\nPick an ELevation-Block to edit: <Exit>")))
	(if en
		(if
			(and
				(= (cdr (assoc 0 (setq ent (entget en)))) "INSERT")
				(= (substr (cdr (assoc 2 (entget en))) 1 2) "EL")	
			)
			(progn
				(setq
					pt0	(cdr (assoc 10 ent))
					y0	(cadr (trans pt0 0 1))
					a0	(atof (cdr (assoc 1 (entget (entnext en)))))
				)
				(while (setq pt1 (getpoint (trans pt0 0 1) "\nInsert point: <Exit>"))
					(insert_el (princ (rtos (+ a0 (* (- (cadr pt1) y0) UNIT_SCALE)) 2 3)))
				)
			)
			(princ "\n1 was not ELevation-Block. ")
		)
	)
)

(defun el_move (/ ss rpt pt1 pt2 ang dis val count en_el ent_el pt_el en_att ent_att pt_att attr)
	(prompt "\nSelect ELevation-Insert(s) to edit: ")
	(setq ss (ssget '((0 . "INSERT") (2 . "el??"))))
	(if ss
		(progn
			(setq
				rpt	(sslength ss)
				pt1	(getpoint "\nBase point or displacement: ")
				pt2	(getpoint pt1 "Second point of displacement: ")
				ang	(angle (trans pt1 1 0) (trans pt2 1 0))
				dis	(distance pt1 pt2)
				val	(* (- (cadr pt2) (cadr pt1)) UNIT_SCALE)
				idx	0
			)
			(repeat rpt
				(setq
					en_el	(ssname ss idx)
					ent_el	(entget en_el)
					en_att	(entnext en_el)
					ent_att	(entget en_att)
					pt_el	(polar (cdr (assoc 10 ent_el)) ang dis)
					pt_att1	(polar (cdr (assoc 10 ent_att)) ang dis)
					pt_att2	(polar (cdr (assoc 11 ent_att)) ang dis)
					attr	(rtos (+ (atof (cdr (assoc 1 ent_att))) val) 2 3)
				)
				(if (= attr "0.000") (setq attr "%%P0.000"))
				(entmod (subst (cons 10 pt_el) (assoc 10 ent_el) ent_el))
				(setq
					ent_att (subst (cons 10 pt_att1) (assoc 10 ent_att) ent_att)
					ent_att (subst (cons 11 pt_att2) (assoc 11 ent_att) ent_att)
				)
				(entmod (subst (cons 1 attr) (assoc 1 ent_att) ent_att))
				(entupd en_el)
				(setq idx (1+ idx))
			)
		)
	)
)

(defun el_array (/ ss os cl rpt idx row dis en_el ent_el pt_el0 bkname ele_0 times pt_el1 attr1)
	(prompt "\nSelect EL-Block(s) to edit: ")
	(setq ss (ssget '((0 . "INSERT") (2 . "el??"))))
	(if ss
		(progn
			(setq
				rpt (sslength ss)
				idx 0
				row (getint "\nNumber of rows (---): ")
				dis (getdist "\nDistance between rows (---): ")
			)
			(repeat rpt
				(setq
					en_el	(ssname ss idx)
					ent_el	(entget en_el)
					pt_el0	(cdr (assoc 10 ent_el))
					bkname	(cdr (assoc 2 ent_el))
					ele_0	(atof (cdr (assoc 1 (entget (entnext en_el)))))
					times	1
				)
				(while (< times row)
					(setq
						pt_el1	(subst (+ (cadr pt_el0) (* dis times)) (cadr pt_el0) pt_el0)
						attr1	(rtos (+ ele_0 (* dis times UNIT_SCALE)) 2 3)
					)
					(if (= attr1 "0.000") (setq attr1 "%%P0.000"))
					(setq os (getvar "osmode"))
					(setvar "clayer" FLLT_DIM0)
					(setvar "osmode" 0)
					(setvar "cmdecho" 0)
					(cmd "_insert" bkname pt_el1 EL_SCALE EL_SCALE 0 attr1)
					(setvar "osmode" os)
					(setq times (1+ times))
				)
				(setq idx (1+ idx))
			)
			(setvar "osmode" os)
			(setvar "cmdecho" 1)
			(setvar "clayer" cl)
		)
	)
)

(defun el_plan_mode (/ pt1)
	(setq el_copy nil el_move nil el_array nil EL_BASE_Y nil el_main nil el_insert nil insert_el nil)
	(initget "Elevation UR UL DR DL")
	(setq pt1 (getpoint (strcat "\nElevation mode/block[" EL_SUFFIX "]/<insert point>: "))
	(cond
		((listp pt1) (insert_plan_mode))
		((= pt1 "Elevation")
			(load "elins2")
			(c:elin)
		)
		((= pt1 "Style") (el_sty))
		((= pt1 "Insert") (insert_plan_mode))
		(t)
	)
)

(defun insert_plan_mode (/ os)
	(setq os (getvar "osmode"))
	(setvar "osmode" 0)
	(setvar "cmdecho" 0)
	(if (= (type pt1) 'STR) (setq pt1 (getpoint "\nInsert point: <Exit>")))
	(while pt1
		(setq str (getstring "\nElevation: "))
		(setvar "osmode" 0)
		(cmd "_insert" (strcat "EL" EL_SUFFIX) pt1 EL_SCALE EL_SCALE 0 str)
		(setvar "osmode" os)
		(setq pt1 (getpoint "\nInsert point: <Exit>"))
	)
	(setvar "osmode" os)
	(setvar "cmdecho" 1)
)

(defun el_base (/ hx)
	(if (setq el_bpt (getpoint "\nBase point: "))
		(setq 	hx (getreal "\nElevation: <0.000>")
				hx (if hx hx 0.0)
				EL_BASE_Y (- (cadr el_bpt) (/ hx UNIT_SCALE))
		)
		(princ "\nBase NOT changed. ")
	)
)

(defun el_ini (/ pt0 hx)
	(initget "Plan")
	(setq pt0 (getpoint "\nPlan mode/<base point>: "))
	(cond
		((listp pt1)
			(setq hx (getreal "\nElevation of base point: <0.000>"))
			(if (= hx nil) (setq hx 0.0))
			(setq EL_BASE_Y (- (cadr pt0) (/ hx UNIT_SCALE)))
			(setq el_bpt pt0)
		)
		((= pt0 "Plan")
			(defun c:elin ()
				(el_plan_mode)
				(princ)
			)
			(c:elin)
		)
	)
	(if (= (tblsearch "layer" FLLT_DIM0) nil)
		(cmd "layer" "n" FLLT_DIM0 "c" "g" FLLT_DIM0 "")
	)
	(setvar "attmode" 1)
	(princ)
)

(defun elunld ()
	(mapcar
		'(lambda (x) (setq x nil))
		'(el_main el_insert insert_el el_copy el_move el_array el_plan_mode insert_plan_mode el_val EL_BASE_Ylp el_base el_ini elunld EL_BASE_Y EL_SUFFIX)
	)
	(defun c:elin () (load "elins3") (c:elin) (princ))
	(princ "\nAppliction unloaded. Type ELIN to reload and run.")
)

(defun el_und ()
	(cmd "_undo" "e")
	(cmd "_undo")
	(elins)
)

(princ "start as C:ELIN")
(princ)